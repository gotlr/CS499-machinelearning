pred.mat=NNetIterations(X.mat,y.vec,20L,0.5,15L,is.train)
View(pred.mat)
dim(pred.mat)
pred.mat
pred.mat[1]
dim(pred.mat[1])
dim(as.array(pred.mat[1])
dim(as.array(pred.mat[1])
dim(as.array(pred.mat[1]))
as.array(pred.mat[1])
dim(as.array(pred.mat[1]))
View(pred.mat)
library(NeuralNetwork1)
pred.mat=NNetIterations(X.mat,y.vec,20L,0.5,15L,is.train)
pred.mat
dim(pred.mat)
View(pred.mat)
y.vec
pred.mat=NNetIterations(X.mat,y.vec,200L,0.5,15L,is.train)
y.vec
y.vec
all(y.vec %in% c(0,1))
X.mat
y.vec
is.binary
if (all(y.vec %in% c(0,1)))
is.binary = 1 else
is.binary = 0
is.binary
n.observations <- nrow(X.mat)
n.features <- ncol(X.mat)
train.index = which(is.train==TRUE)
validation.index = which(is.train!=TRUE)
X.train = X.mat[train.index,]
y.train = y.vec[train.index]
X.scaled.validation = X.scaled.mat[validation.index,]
y.validation = y.vec[validation.index]
train.index = which(is.train==TRUE)
validation.index = which(is.train!=TRUE)
X.train = X.mat[train.index,]
y.train = y.vec[train.index]
X.validation = X.mat[validation.index,]
y.validation = y.vec[validation.index]
X.train
is.train
X.validation
X.train.min = colMeans(X.train)
X.temp=t(t(X.train)-X.train.min)
X.train.sd=sqrt(colSums((X.temp)^2)/dim(X.train)[1])
X.scaled.train=t(t(X.temp)/X.train.sd)
X.scaled.train
n.hidden.units
max.iterations
max.iterations=5
W.mat <- matrix(runif(n.features * n.hidden.units, 0, 0.2),
n.features, n.hidden.units)
dim(W.mat)
W.mat
V.mat = matrix(rnorm(n.features*n.hidden.units),n.features,n.hidden.units)
V.mat
w.vec = rnorm(n.hidden.units)
w.vec
v.vec <- runif(n.hidden.units, 0, 0.2)
v.vec
X.a.mat = X.scaled.mat%*%V.mat
X.a.mat = X.scaled.train%*%V.mat
X.z.mat = sigmoid(X.a.mat)
X.b.vec = X.z.mat %*% w.vec
w.gradient = (t(X.z.mat) %*% delta.w)/n.observations
delta.w = X.b.vec - y.vec
X.b.vec
delta.w = X.b.vec - y.train
delta.v = diag(as.vector(delta.v)) %*% desigmoid(X.a.mat)
delta.v = diag(as.vector(delta.w)) %*% desigmoid(X.a.mat)
desigmoid=function(x){
return(exp(-x)/(1+exp(-x))^2)
desigmoid=function(x){
return(exp(-x)/(1+exp(-x))^2)
}
desigmoid=function(x){
return(exp(-x)/(1+exp(-x))^2)
}
delta.v = diag(as.vector(delta.w)) %*% desigmoid(X.a.mat)
w.gradient = (t(X.z.mat) %*% delta.w)/n.observations
v.gradient = (t(X.scaled.mat) %*% delta.W)/ n.observations
delta.w = X.b.vec - y.train
delta.v = diag(as.vector(delta.w)) %*% desigmoid(X.a.mat)
w.gradient = (t(X.z.mat) %*% delta.w)/n.observations
v.gradient = (t(X.scaled.mat) %*% delta.W)/ n.observations
v.gradient = (t(X.scaled.mat) %*% delta.w)/ n.observations
v.gradient = (t(X.scaled.train) %*% delta.w)/ n.observations
v.vec = v.vec - step.size*v.gradient
w.mat = W.mat - step.size*W.gradient
w.gradient = (t(X.z.mat) %*% delta.w)/n.observations
w.gradient
v.gradient
v.gradient = (t(X.scaled.train) %*% delta.v)/ n.observations
v.gradient
v.vec
v.vec <- c(intercept.v, v.vec)
v.vec <- c(intercept.vec, v.vec)
v.vec
w.vec
v.mat
v.mat = matrix(rnorm(n.features*n.hidden.units),n.features,n.hidden.units)
v.mat = v.mat - step.size*v.gradient
v.mat
step.size * delta.w
x.train.mat
X.train
dim(X.train)
interception.vec = rep(0,dim(x.train)[1])
interception.vec = rep(0,dim(X.train)[1])
interception.vec = interception.vec - step.size * delta.w
interception.vec
w.vec
c(interception.vec, w.vec)
X.mat
cbind(1,X.mat)
rbind(-t(w.mat) %*% X.train.sd %*% X.train.min, t(t(w.mat) %*% X.train.sd))
interception.vec
c(interception.vec,1)
X.b.vec
y.train*X.b.vec
exp(y.train*X.b.vec)
1+exp(y.train*X.b.vec)
1/1+exp(y.train*X.b.vec)
y.train/1+exp(y.train*X.b.vec)
delta.v = diag(as.vector(delta.w)) %*% desigmoid(X.a.mat)
all(y.train!=1)
all(y.train!=1||0)
all(y.train==1|y.train==|0)
all(y.train==1||y.train==0)
which(y.train==1)
y[which(y.train==1)]
y.train[which(y.train==1)]
y.train[which(y.train==2)]
y.train[which(y.train==3)]
y.train[which(y.train==4)]
y.train
y.train[which(y.train==14)]
which(y.train==14)
y.train[which(y.train==14)]=1
y.train[which(y.train==14)]
X.b.vec
ifelse(sigmoid(x.b.vec)>0.5,1)
x.b.X.b.vec
X.b.vec
ifelse(sigmoid(X.b.vec)>0.5,1)
ifelse(x.b.vec>0.5)
ifelse(X.b.vec>0.5)
ifelse(X.b.vec>0.5,1,0.5])
ifelse(X.b.vec>0.5,1,0.5)
v.mat = matrix(rnorm((n.features+1)*n.hidden.units),n.features+1,n.hidden.units)
w.vec = rnorm(n.hidden.units+1)
v.gradient=rep(0,n.hidden.units+1)
W.gradient=matrix(0,n.features+1,n.hidden.units)
X.a.mat = cbind(1,X.scaled.train)%*%v.mat
X.z.mat = sigmoid(X.a.mat)
X.b.vec = cbind(1,X.z.mat) %*% w.vec
X.b.vec
pred.mat
n.folds=4
y.vec
sample(rep(1:n.folds), length(y.vec))
sample(rep(1:n.folds), length(y.vec),TRUE)
fold.number=1
fold.vec = sample(rep(1:n.folds), length(y.vec),TRUE)
which(fold.vec == fold.number)
is.train[which(fold.vec == fold.number)] = FALSE
is.train[which(fold.vec != fold.number)] = FALSE
is.train
is.train[which(fold.vec != fold.number)] = TRUE
is.train
library(NeuralNetwork1)
NNetIterations(X.mat,y.vec,15L,0.5,5L,is.train)
is.train
library(NeuralNetwork1)
NNetIterations(X.mat,y.vec,15L,0.5,5L,is.train)
w.gradient
w.vec
w.gradient = (t(X.z.mat) %*% delta.w)/n.observations
w.gradient
w.vec = rnorm(n.hidden.units+1)
w.vec = w.vec - step.size*w.gradient
w.vec
w.gradeint
w.gradient
X.a.mat = cbind(1,X.scaled.train)%*%v.mat
dim(X.a.mat)
cbind(1,X.scaled.train)
X.z.mat = sigmoid(X.a.mat)
X.b.vec = cbind(1,X.z.mat) %*% w.vec
dim(X.b.vec)
library(NeuralNetwork1)
NNetIterations(X.mat,y.vec,15L,0.5,5L,is.train)
delta.w = X.b.vec - y.train
delta.v = diag(as.vector(delta.w)) %*% desigmoid(cbind(1,X.a.mat))
dim(delta.v)
desigmoid(cbind(1,X.a.mat))
dim(desigmoid(cbind(1,X.a.mat)))
dim(X.a.mat)
dim(delta.v)
v.gradient = (t(X.scaled.train) %*% delta.v)/ n.observations
dim(v.gradient)
dim(w.gradient)
X.z.mat
dim(X.a.mat)
w.gradient = (t(cbind(1,X.z.mat)) %*% delta.w)/n.observations
dim(w.gradient)
w.vec = w.vec - step.size*w.gradient
v.mat = v.mat - step.size*v.gradient
v.gradient
v.mat
v.gradient = (t(X.scaled.train) %*% delta.v)/ n.observations
v.gradient
delta.v = diag(as.vector(delta.w)) %*% desigmoid(X.a.mat)
v.gradient = (t(cbind(1,X.scaled.train)) %*% delta.v)/ n.observations
v.gradient
v.mat = v.mat - step.size*v.gradient
library(NeuralNetwork1)
NNetIterations(X.mat,y.vec,15L,0.5,5L,is.train)
a=NNetIterations(X.mat,y.vec,15L,0.5,5L,is.train)
View(a)
cbind(1,sigmoid(cbind(1,X.mat)%*%v.mat))%*%w.vec
X.mat
v.mat
w.vec
y.vec
sigmoid(cbind(1,X.mat)%*%v.mat)
cbind(1,X.mat)%*%v.mat
sigmoid(cbind(1,X.mat)%*%v.mat)
library(NeuralNetwork1)
a=NNetIterations(X.mat,y.vec,15L,0.5,5L,is.train)
a
a$pred.mat
pre.mat = NNetIterations(X.mat.y.vec,max.iterations,step.size,n.hidden.units,is.train)$pre.mat
X.mat
pre.mat = NNetIterations(X.mat,y.vec,max.iterations,step.size,n.hidden.units,is.train)$pre.mat
max.iterations
max.iterations=5L
pre.mat = NNetIterations(X.mat,y.vec,max.iterations,step.size,n.hidden.units,is.train)$pre.mat
which(is.train = TURE)
which(is.train == TURE)
which(is.train == TRUE)
pre.mat[which(is.train == TRUE),]
pr.mat
pre.mat
NNetIterations(X.mat,y.vec,max.iterations,step.size,n.hidden.units,is.train)
NNetIterations(X.mat,y.vec,max.iterations,step.size,n.hidden.units,is.train)$pre.mat
NNetIterations(X.mat,y.vec,max.iterations,step.size,n.hidden.units,is.train)$1
NNetIterations(X.mat,y.vec,max.iterations,step.size,n.hidden.units,is.train)$[1]
NNetIterations(X.mat,y.vec,max.iterations,step.size,n.hidden.units,is.train)[1]
NNetIterations(X.mat,y.vec,max.iterations,step.size,n.hidden.units,is.train)[$pre.mat]
NNetIterations(X.mat,y.vec,max.iterations,step.size,n.hidden.units,is.train)$w.mat
NNetIterations(X.mat,y.vec,max.iterations,step.size,n.hidden.units,is.train)$pred.mat
pred.mat = NNetIterations(X.mat,y.vec,max.iterations,step.size,n.hidden.units,is.train)$pred.mat
pred.mat[which(is.train == TRUE),]
colSum(pred.mat[which(is.train == TRUE),])
colSums(pred.mat[which(is.train == TRUE),])
mean.validation.loss.vec = colSums(pred.mat[which(is.train != TRUE),])
for(fold.number in 1:n.folds){
is.train[which(fold.vec == fold.number)] = FALSE
is.train[which(fold.vec != fold.number)] = TRUE
pred.mat = NNetIterations(X.mat,y.vec,max.iterations,step.size,n.hidden.units,is.train)$pred.mat
mean.train.loss.vec = mean.train.loss.vec + colMeans(pred.mat[which(is.train == TRUE),])
mean.validation.loss.vec = mean.validation.loss.ve + colMeans(pred.mat[which(is.train != TRUE),])
}
mean.train.loss.vec =  rep(0,max.iterations)
mean.validation.loss.vec =  rep(0,max.iterations)
for(fold.number in 1:n.folds){
is.train[which(fold.vec == fold.number)] = FALSE
is.train[which(fold.vec != fold.number)] = TRUE
pred.mat = NNetIterations(X.mat,y.vec,max.iterations,step.size,n.hidden.units,is.train)$pred.mat
mean.train.loss.vec = mean.train.loss.vec + colMeans(pred.mat[which(is.train == TRUE),])
mean.validation.loss.vec = mean.validation.loss.ve + colMeans(pred.mat[which(is.train != TRUE),])
}
for(fold.number in 1:n.folds){
is.train[which(fold.vec == fold.number)] = FALSE
is.train[which(fold.vec != fold.number)] = TRUE
pred.mat = NNetIterations(X.mat,y.vec,max.iterations,step.size,n.hidden.units,is.train)$pred.mat
mean.train.loss.vec = mean.train.loss.vec + colMeans(pred.mat[which(is.train == TRUE),])
mean.validation.loss.vec = mean.validation.loss.vec + colMeans(pred.mat[which(is.train != TRUE),])
}
mean.train.loss.vec
mean.validation.loss.vec
library(NeuralNetwork1)
library(NeuralNetwork1)
NNetEarlyStoppingCV(X.mat,y.vec,fold.vec,max.iterations,step.size,n.hidden.units,n.folds=4)
library(NeuralNetwork1)
NNetEarlyStoppingCV(X.mat,y.vec,fold.vec,max.iterations,step.size,n.hidden.units,n.folds=4)
a=NNetEarlyStoppingCV(X.mat,y.vec,fold.vec,max.iterations,step.size,n.hidden.units,n.folds=4)
a
data(spam, package = "ElemStatLearn")
spam
View(spam)
y.vec <- spam[, 1]
y.vec
dim(spam)
y.vec=dim(spam)[2]
y.vec
y.vec=spam[,dim(spam)[2]]
y.vec
spam
spam[],57
y.vec=spam[,dim(spam)[2]-1]
y.vec
spam
y.vec=spam[,dim(spam)[2]]
y.vec
all(y.vec == 'spam')
which(y.vec != 'spam')
y.vec[1]
y.vec[2]
y.vec[3]
y.vec[100]
y.vec[1000]
data(spam, package = "ElemStatLearn")
X.mat <- data.matrix(spam[,-ncol(spam)])
y.vec <- as.vector(ifelse(spam$spam == 'spam',1,0))
y.vec
data(SAheart, package = "ElemStatLearn")
X.mat <- as.matrix(ozone[,-1])
y.vec <- SAheart[,dim(SAheart)[2]]
y.vec
X.mat = SAheart[,dim(SAheart)[2]]
n.folds = 4
fold.vec = sample(rep(1:n.folds), length(y.vec),TRUE)
n.folds = 4
fold.vec = sample(rep(1:n.folds), length(y.vec),TRUE)
max.iterations = 30L
step.size = 0.5
n.hidden.units = 15L
NNetEarlyStoppingCV(X.mat,y.vec,fold.vec,max.iterations,step.size,n.hidden.units,n.folds=4)
X.mat
X.mat = SAheart[,-dim(SAheart)[2]]
NNetEarlyStoppingCV(X.mat,y.vec,fold.vec,max.iterations,step.size,n.hidden.units,n.folds=4)
X.mat
which(as.(X.mat)
as.numeric(X.mat)
is.numeric(X.mat)
which(is.numberic(X.mat)
which(is.numberic(X.mat))
which(is.numeric(X.mat))
which(X.mat[1,])
unique(X.mat[,1])
unique(X.mat[1,])
table(X.mat[1,])
for(index = 1:length(X.mat[1,])){}
X.mat
unique(X.mat[,5])
ifelse(X.mat[,5]=='Absent',1,2)
X.mat[,5]=ifelse(X.mat[,5]=='Absent',1,2)
X.mat
NNetEarlyStoppingCV(X.mat,y.vec,fold.vec,max.iterations,step.size,n.hidden.units,n.folds=4)
X.mat
!all(is.matrix(X.mat),is.numeric(X.mat))
is.matrix(X.mat)
dim(X.mat)
is.matrix(X.mat)
a=matrix(0,2,3)
is.matrix(a)
X.mat = as.matrix(SAheart[,-dim(SAheart)[2]])
X.mat
SAheart[,-dim(SAheart)[2]]
is.numeric(X.mat[1,1])
as.numeric(X.matrix)
as.numeric(X.mat)
X.mat = (SAheart[,-dim(SAheart)[2]])
as.numeric(y.vec)
is.numeric(y.vec)
X.mat[,5]=ifelse(X.mat[,5]=='Absent',1,2)
X.mat = as.numeric((SAheart[,-dim(SAheart)[2]]))
X.mat
X.mat = as.numeric((SAheart[,-dim(SAheart)[2]]))
getClass(X.mat)
X.mat[1]
X.mat[2]
X.mat = data.matrix(SAheart[,-dim(SAheart)[2]])
X.mat
!all(is.matrix(X.mat),is.numeric(X.mat))
X.mat = data.matrix(SAheart[,-dim(SAheart)[2]])
X.mat
data(spam, package = "ElemStatLearn")
y.vec = as.vector(SAheart[,dim(SAheart)[2]])
X.mat = data.matrix(SAheart[,-dim(SAheart)[2]])
X.mat
data(SAheart, package = "ElemStatLearn")
y.vec = as.vector(SAheart[,dim(SAheart)[2]])
X.mat = data.matrix(SAheart[,-dim(SAheart)[2]])
X.mat
X.mat = SAheart[,-dim(SAheart)[2]]
X.mat
X.mat = data.matrix(SAheart[,-dim(SAheart)[2]])
NNetEarlyStoppingCV(X.mat,y.vec,fold.vec,max.iterations,step.size,n.hidden.units,n.folds=4)
n.observations <- nrow(X.mat)
n.features <- ncol(X.mat)
X.train.min = colMeans(X.mat)
X.temp=t(t(X.mat)-X.train.min)
X.train.sd=sqrt(colSums((X.temp)^2)/dim(X.mat)[1])
X.scaled.train=t(t(X.temp)/X.train.sd)
X.scaled.train
View(X.scale.mat)
dim(X.scale.mat)
X.scaled.train
View(X.scaled.train)
pred.mat = matrix(0,n.observations, max.iterations)
v.mat = matrix(rnorm((n.features+1)*n.hidden.units),n.features+1,n.hidden.units)
w.vec = rnorm(n.hidden.units+1)
v.gradient=rep(0,n.hidden.units+1)
W.gradient=matrix(0,n.features+1,n.hidden.units)
sigmoid = function(x){
return(1/(1+exp(-x)))
}
desigmoid=function(x){
return(exp(-x)/(1+exp(-x))^2)
}
X.a.mat = cbind(1,X.scaled.train)%*%v.mat
X.z.mat = sigmoid(X.a.mat)
X.b.vec = cbind(1,X.z.mat) %*% w.vec
pred.mat[,iteration] = sigmoid(cbind(1,sigmoid(cbind(1,X.mat)%*%v.mat))%*%w.vec)
y.tilde.train = y.train
y.tilde.train[which(y.tilde.train==0)] = -1
delta.w = -y.train/1+exp(y.train*X.b.vec)
delta.w = -y.train/(1+exp(y.train*X.b.vec))
y.train
y.train=y.vec
pred.mat[,iteration] = sigmoid(cbind(1,sigmoid(cbind(1,X.mat)%*%v.mat))%*%w.vec)
y.tilde.train = y.train
y.tilde.train[which(y.tilde.train==0)] = -1
delta.w = -y.train/(1+exp(y.train*X.b.vec))
delta.v = diag(as.vector(delta.w)) %*% desigmoid(cbind(1,X.a.mat))
w.gradient = (t(cbind(1,X.z.mat)) %*% delta.w)/n.observations
v.gradient = (t(cbind(1,X.scaled.train)) %*% delta.v)/ n.observations
dim(w.vec)
length(w.vec)
v.gradient
w.gradient
w.vec = w.vec - step.size*as.vector(w.gradient)
v.mat = v.mat - step.size*v.gradient
dim(v.mat)
dim(X.mat)
dim(v.gradient)
dim(delta.v)
delta.w
dim(X.a.mat)
delta.v = diag(as.vector(delta.w)) %*% desigmoid(X.a.mat)
dim(delta.v)
dim(X.mat)
dim(t(cbind(1,X.scaled.train)) %*% delta.v)
dim(v.gradient)
dim(v.mat)
dim(delta.v)
dim(t(cbind(1,X.scaled.train))
dim(t(cbind(1,X.scaled.train)))
delta.v = diag(as.vector(delta.w)) %*% desigmoid(X.a.mat)
dim(delta.v)
v.gradient = (t(cbind(1,X.scaled.train)) %*% delta.v)/ n.observations
dim(v.gradient)
dim(v.mat)
X.a.mat = cbind(1,X.scaled.train)%*%v.mat
X.z.mat = sigmoid(X.a.mat)
X.b.vec = cbind(1,X.z.mat) %*% w.vec
y.tilde.train = y.train
y.tilde.train[which(y.tilde.train==0)] = -1 # change y into non-zero number
delta.w = -y.train/(1+exp(y.train*X.b.vec))
delta.v = diag(as.vector(delta.w)) %*% desigmoid(cbind(1,X.a.mat))
dim(delta.v)
delta.v = diag(as.vector(delta.w)) %*% desigmoid(X.a.mat)
dim(delta.v)
w.gradient = (t(cbind(1,X.z.mat)) %*% delta.w)/n.observations
v.gradient = (t(cbind(1,X.scaled.train)) %*% delta.v)/ n.observations
w.vec = w.vec - step.size*as.vector(w.gradient)
v.mat = v.mat - step.size*v.gradient
is.train = rep(0,length(y.vec))
is.train[1]
is.train[1]="FLASE"
is.train[1]=FLASE
is.train[1]=FALSE
is.train
is.train = rep(0,length(y.vec))
is.train
is.train[1]=FALSE
is.train
is.train[1]=TRUE
is.train
which(is.train == TRUE)
library(NeuralNetwork1)
NNetEarlyStoppingCV(X.mat,y.vec,fold.vec,max.iterations,step.size,n.hidden.units,n.folds=4)
dim(X.mat)
dim(y.vec)
data(SAheart, package = "ElemStatLearn")
y.vec = as.vector(SAheart[,dim(SAheart)[2]])
X.mat = SAheart[,-dim(SAheart)[2]]
n.folds = 4
fold.vec = sample(rep(1:n.folds), length(y.vec),TRUE)
max.iterations = 30L
step.size = 0.5
n.hidden.units = 15L
X.mat = data.matrix(SAheart[,-dim(SAheart)[2]])
y.vec
NNetEarlyStoppingCV(X.mat,y.vec,fold.vec,max.iterations,step.size,n.hidden.units,n.folds=4)
y.vec
length(y.vec)
dim(X.mat)
data(prostate, package = "ElemStatLearn")
prostate
y.vec = as.vector(prostate[,dim(SAheart)[2]-1])
y.vec
X.mat = SAheart[,c(-dim(SAheart)[2],-dim(SAheart)[2]-1)]
X.mat
library(NeuralNetwork1)

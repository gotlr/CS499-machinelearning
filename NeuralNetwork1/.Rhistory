X.mat.min = colMeans(X.mat)
X.mat.sd=sqrt(colSums((t(t(X.mat)-X.mat.min))^2)/dim(X.mat)[1])
X.scale.mat=t((t(X.mat-X.mat.min)*(1/X.mat.sd)))
X.scale.mat
X.mat.min = colMeans(X.mat)
X.temp=t(t(X.mat)-X.mat.min)
X.mat.sd=sqrt(colSums((x.temp)^2)/dim(X.mat)[1])
X.mat.min = colMeans(X.mat)
X.temp=t(t(X.mat)-X.mat.min)
X.mat.sd=sqrt(colSums((X.temp)^2)/dim(X.mat)[1])
X.mat.sd
t(X.temp)
X.mat.sd
t(X.temp)/X.mat.sd
X.mat.min = colMeans(X.mat)
X.temp=t(t(X.mat)-X.mat.min)
X.mat.sd=sqrt(colSums((X.temp)^2)/dim(X.mat)[1])
X.scale.mat=t(t(X.temp)/X.mat.sd)
X.scale.mat
colMeans(X.scale.mat)
runif(2,0,2)
matrix(rnorm(4),2,2)
sigmoid = function(x){
return(1/(1+exp(-x)))
}
x=c(1,2)
sigmoid(x)
data(SAheart, package = "ElemStatLearn")
data(prostate, package = "ElemStatLearn")
X.scaled.mat <- data.matrix(subset(prostate, select = -c(train, lpsa)))
y.vec <- as.vector(data.matrix(subset(prostate, select = lpsa)))
dim(X.scale.mat)
X.scaled.mat
dim(X.scaled.mat)
pred.mat = matrix(0,n.obeservation, max.iterations)
W.mat = matrix(rnorm(n.obeservations*n.hidden.units),n.features,n.hidden.units)
v.vec = rnorm(n.hidden.units)
n.obeservations <- nrow(X.mat)
n.features <- ncol(X.mat)
n.hidden.units=3L
x.train.vec=x.scaled.mat[1]
X.train.vec=X.scaled.mat[1]
W.mat
W.mat = matrix(rnorm(n.obeservations*n.hidden.units),n.features,n.hidden.units)
n.obeservations
n.obeservations <- nrow(X.scaled.mat)
n.features <- ncol(X.scale.mat)
pred.mat = matrix(0,n.obeservation, max.iterations)
pred.mat = matrix(0,n.obeservations, max.iterations)
W.mat = matrix(rnorm(n.obeservations*n.hidden.units),n.features,n.hidden.units)
n.obeservations
n.hidden.units
W.mat = matrix(rnorm(n.features*n.hidden.units),n.features,n.hidden.units)
v.vec = rnorm(n.hidden.units)
View(W.mat)
X.train.ai=X.train.vec%*%W.mat
dim(X>train.vec)
dim(X.train.vec)
X.train.vec
X.train.vec=X.scaled.mat[index,]
X.train.vec=X.scaled.mat[1,]
X.train.ai=X.train.vec%*%W.mat
dim(X>train.vec)
dim(X.train.vec)
X.train.vec
X.train.ai=X.train.vec.W.mat
X.train.ai=X.train.vec*W.mat
dim(W.mat)
dim(X.train.ai)
length(X.train.vec)
X.mat
y.vec
y.vec=c(1,1,0,1)
n.obeservations <- nrow(X.mat)
n.features <- ncol(X.mat)
X.mat.min = colMeans(X.mat)
X.temp=t(t(X.mat)-X.mat.min)
X.mat.sd=sqrt(colSums((X.temp)^2)/dim(X.mat)[1])
X.scaled.mat=t(t(X.temp)/X.mat.sd)
train.index = which(is.train==TRUE)
validation.index = which(is.train!=TRUE)
X.scaled.train = X.scale.mat[train.index,]
y.train = y.vec[train.index]
X.scaled.validation = X.scale.mat[validation.index,]
y.validation = y.vec[validation.index]
pred.mat = matrix(0,n.obeservations, max.iterations)
W.mat = matrix(rnorm(n.features*n.hidden.units),n.features,n.hidden.units)
v.vec = rnorm(n.hidden.units)
v.vec
X.train.vec=X.scaled.train[1,]
X.train.vec
length(X.train.vec)
dim(W.mat)
X.train.vec*W.mat
X.train.vec%*%W.mat
X.train.zi=sigmoid(X.train.ai)
X.train.zi
X.train.ai=X.train.vec%*%W.mat
X.train.zi=sigmoid(X.train.ai)
X.train.zi
v.vec
v.vec*X.train.zi
v.vec%*%X.train.zi
t(v.vec)%*%X.train.zi
dim(t(v.vec))
X.train.zi
t(v.vec)*X.train.zi
X>train.zi
X.train.zi
v.vec%*%X.train.zi
crossprod(v.vec,X.train.zi)
v.vec
X.train.zi
X.train.zi*v.vec
t(v.vec)
t(t(vec))
t(t(v.vec))
t(t(v.vec))%*%X.train.zi
X.train.zi%*%v.vec
v.vec
X.train.zi
v.vec
X>train.zi%*%v.vec
X.train.zi%*%v.vec
v.vec%*%X.train.zi
X.train.bi=X.train.zi%*%v.vec
X.train.bi
y.train
yi.hat=Xi.train.b
Xi.train.vec=Xi.scaled.train[index,]
Xi.train.a=Xi.train.vec%*%W.mat
Xi.train.z=sigmoid(Xi.train.a)
Xi.train.b=Xi.train.z%*%v.vec
Xi.train.vec=Xi.scaled.train[1,]
Xi.train.a=Xi.train.vec%*%W.mat
Xi.train.z=sigmoid(Xi.train.a)
Xi.train.b=Xi.train.z%*%v.vec
Xi.train.vec=X.scaled.train[1,]
Xi.train.a=Xi.train.vec%*%W.mat
Xi.train.z=sigmoid(Xi.train.a)
Xi.train.b=Xi.train.z%*%v.vec
yi.hat=Xi.train.b
w.gradient=(yi.hat-y.train[index])*Xi.train.z
w.gradient=(yi.hat-y.train[1])*Xi.train.z
yi.hat-y.train[index]
yi.hat-y.train[1]
w.gradient=(yi.hat-y.train[index])%*%Xi.train.z
w.gradient=(yi.hat-y.train[1)%*%Xi.train.z
w.gradient=(yi.hat-y.train[1)%*%Xi.train.z)
w.gradient=(yi.hat-y.train[1)%*%Xi.train.z
w.gradient=(yi.hat-y.train[1]%*%Xi.train.z
w.gradient=yi.hat-y.train[1]%*%Xi.train.z
w.gradient=(yi.hat-y.train[1])%*%Xi.train.z
W.gradirnt
W.gradient
w.gradient
v.gradient.vec=0.5*(yi.hat-y.train[index])%*%Xi.train.z
v.gradient.vec=0.5*(yi.hat-y.train[1])%*%Xi.train.z
Xi.train.a
t(X.scaled.train) %*% ((Xi.train.b - y.train) %*% t(v.vec)
Xi.train.a
v.vec
v.vec%*%Xi.train.a
t(v.vec)*Xi.train.a
t(v.vec)
t(v.vec)%*%Xi.train.a
v.vec%*%Xi.train.a
Xi.train.a%*%v.vec
diag(v.vec)
diag(v.vec)%*%Xi.train.a
Xi.train.a%&%diag(v.vec)
Xi.train.a%*%diag(v.vec)
Xi.train.a%*%diag(v.vec)
Xi.train.a
v.vec
t(Xi.train.a%*%diag(v.vec))
Xi.train.a%*%diag(sigmoid_return(v.vec)
Xi.train.a%*%diag(sigmoid_return(v.vec))
sigmoid_return=function(x){
return(exp(-x)/(1+exp(-x))^2)
}
Xi.train.a%*%diag(sigmoid_return(v.vec))
0.5*(yi.hat-y.train[1])
0.5*(yi.hat-y.train[1])*t(Xi.train.a%*%diag(sigmoid_return(v.vec)))
t(Xi.train.a%*%diag(sigmoid_return(v.vec)))
0.5*(yi.hat-y.train[index])
0.5*(yi.hat-y.train[1])
0.5*(yi.hat-y.train[1])%*%t(Xi.train.a%*%diag(sigmoid_return(v.vec)))
0.5*t(Xi.train.a%*%diag(sigmoid_return(v.vec)))
0.5*t(Xi.train.a%*%diag(sigmoid_return(v.vec)*(yi.hat-y.train[index])
0.5*t(Xi.train.a%*%diag(sigmoid_return(v.vec))*(yi.hat-y.train[index])
0.5*t(Xi.train.a%*%diag(sigmoid_return(v.vec)))
0.5*t(Xi.train.a%*%diag(sigmoid_return(v.vec)))%*%(yi.hat-y.train[1])
yi.hat-y.train[1]
v.gradient=rep(0,n.hidden.units)
Xi.train.vec=X.scaled.train[index,]
Xi.train.a=Xi.train.vec%*%W.mat
Xi.train.z=sigmoid(Xi.train.a)
Xi.train.b=Xi.train.z%*%v.vec
Xi.train.vec=X.scaled.train[1,]
Xi.train.a=Xi.train.vec%*%W.mat
Xi.train.z=sigmoid(Xi.train.a)
Xi.train.b=Xi.train.z%*%v.vec
yi.hat=Xi.train.b
v.gradient.i=0.5*(yi.hat-y.train[index])%*%Xi.train.z
v.gradient.i=0.5*(yi.hat-y.train[1])%*%Xi.train.z
w.gradient.i=0.5*t(Xi.train.a%*%diag(sigmoid_return(v.vec)))%*%(yi.hat-y.train[1])
v.gradient=rep(0,n.hidden.units)
w.gradient=matrix(0,n.features,n.hidden.units)
v.grandient = v.gradient + v.gradient.i
w.gradient = w.gradient + w.gradient.i
w.gradient.i
w.gradient.i=0.5*t(Xi.train.a%*%diag(sigmoid_return(v.vec)))%*%(yi.hat-y.train[1])%*%X.scaled.train[1]
w.gradient
w.gradient.i
X.scaled.train[1]
w.gradient.i=0.5*t(Xi.train.a%*%diag(sigmoid_return(v.vec)))%*%(yi.hat-y.train[1])%*%X.scaled.train[1,]
w.gradient.i
w.gradient = w.gradient + w.gradient.i
w.gradient = w.gradient + t(w.gradient.i)
w.gradient
step.size
(v.gradient / n.observations)
n.observations <- nrow(X.mat)
(v.gradient / n.observations)
v.gradient
v.grandient = v.gradient + v.gradient.i
v.gradient
v.gradient.i=0.5*(yi.hat-y.train[index])%*%Xi.train.z
v.gradient.i=0.5*(yi.hat-y.train[1])%*%Xi.train.z
v.grandient = v.gradient + v.gradient.i
v.gradient
v.gradient
yi.hat
yi.hat-y.train[1]
(yi.hat-y.train[1])%*%Xi.train.z
0.5*(yi.hat-y.train[1])%*%Xi.train.z
v.gradient.i
v.grandient = v.gradient + v.gradient.i
v.grandient
(v.gradient / n.observations)
v.gradient
v.grandient
v.gradient = v.gradient + v.gradient.i
v.vec = v.vec-step.size * (v.gradient / n.observations)
v.vec
v.vec = v.vec-step.size * (v.gradient / n.observations)
v.vec
W.mat = W.mat - step.size * (W.gradient / n.observations)
w.gradient.i=0.5*t(Xi.train.a%*%diag(sigmoid_return(v.vec)))%*%(yi.hat-y.train[index])%*%X.scaled.train[index,]
w.gradient.i=0.5*t(Xi.train.a%*%diag(sigmoid_return(v.vec)))%*%(yi.hat-y.train[1])%*%X.scaled.train[1,]
Xi.train.a
diag(sigmoid_return(v.vec))
v.vec
sigmoid_return(v.vec)
diag(sigmoid_return(v.vec))
diag(1)
diag(11,2)
diag(v.vec)
v.vec
v.gradient=rep(0,n.hidden.units)
v.vec = rnorm(n.hidden.units)
v.vec
v.vec
v.gradient.i=0.5*(yi.hat-y.train[1])%*%Xi.train.z
v.gradient = v.gradient + v.gradient.i
v.gradient
as.vector(v.gradeint)
as.vector(v.gradient)
v.vec = v.vec-step.size * (v.gradient / n.observations)
W.gradient.i=0.5*t(Xi.train.a%*%diag(sigmoid_return(v.vec)))%*%(yi.hat-y.train[1])%*%X.scaled.train[1,]
v.vec = as.vector(v.vec)
W.gradient.i=0.5*t(Xi.train.a%*%diag(sigmoid_return(v.vec)))%*%(yi.hat-y.train[1])%*%X.scaled.train[1,]
W.gradient = w.gradient + t(w.gradient.i)
W.mat = W.mat - step.size * (W.gradient / n.observations)
W.mat
if ((y.vec == 0)|| (y.vec == 1))
is.binary = 1
else
is.binary=1
if ((y.vec == 0)|| (y.vec == 1)){
is.binary = 1
else
is.binary=1
}
?if
?if()
help(if)
else
if ((y.vec == 0)|| (y.vec == 1))
is.binary = 1
else
is.binary=1
if ((y.vec == 0)|| (y.vec == 1))
is.binary = 1 else
is.binary=1
if ((y.vec == 0)|| (y.vec == 1))
is.binary = 1 else
is.binary=1
if ((y.vec == 0)|| (y.vec == 1))
is.binary = 1
else
is.binary=1
is.binary
if ((y.vec == 0)|| (y.vec == 1))
is.binary = 1
is.binary = 0
if ((y.vec == 0)|| (y.vec == 1))
is.binary = 1 else
is.binary = 0
dim(W.mat)
v.vec
X.scaled.mat%*%W.mat
X.scaled.mat%*%W.mat%*%v.vec
X.scaled.mat%*%W.mat%*%t(v.vec)
X.scaled.mat%*%W.mat%*%t(t(v.vec))
pred.vec=sigmoid(X.scaled.mat%*%W.mat)%*%v.vec
pred.vec
dim(pred.vec)
pre.vec = sigmoid(pre.vec)
pred.vec = sigmoid(pred.vec)
pre.vec
pred.vec
pred.vec = sigmoid(pred.vec)
pre.vec
pred.vec
pred.mat
pred.mat[,1]=pred.vec
pred.mat
X.mat
for(iteration in max.iterations){
for (index in dim(X.scaled.train)[index]){
v.vec = as.vector(v.vec)
Xi.train.vec=X.scaled.train[index,]
Xi.train.a=Xi.train.vec%*%W.mat
Xi.train.z=sigmoid(Xi.train.a)
Xi.train.b=Xi.train.z%*%v.vec
if (is.binary)
yi.hat = sigmoid(Xi.train.b) else
yi.hat=Xi.train.b
v.gradient.i=0.5*(yi.hat-y.train[index])%*%Xi.train.z
W.gradient.i=0.5*t(Xi.train.a%*%diag(sigmoid_return(v.vec)))%*%(yi.hat-y.train[index])%*%X.scaled.train[index,]
v.gradient = v.gradient + v.gradient.i
W.gradient = w.gradient + t(w.gradient.i)
}
v.vec = v.vec-step.size * (v.gradient / n.observations)
W.mat = W.mat - step.size * (W.gradient / n.observations)
pred.vec=sigmoid(X.scaled.mat%*%W.mat)%*%v.vec
if(is.binary)
pred.vec = sigmoid(pred.vec)
pred.mat[,iteration]= pred.vec
}
library(NeuralNetwork1)
X.mat
y.vec
NNetIterations(X.mat,y.vec,3L,0.5,3,c(1,2))
library(NeuralNetwork1)
NNetIterations(X.mat,y.vec,3L,0.5,3,c(1,2))
NNetIterations(X.mat,y.vec,3L,0.5,3L,c(1,2))
X.mat
NNetIterations(X.mat,y.vec,3L,0.5,3L,c(TRUE,TRUE,TRUE,FALSE,FALSE))
NNetIterations(X.mat,y.vec,3L,0.5,3L,c(TRUE,TRUE,TRUE,FALSE))
library(NeuralNetwork1)
NNetIterations(X.mat,y.vec,3L,0.5,3L,c(TRUE,TRUE,TRUE,FALSE))
X.scaled.mat%*%W.mat
v.vec
sigmoid(X.scaled.mat%*%W.mat)%*%v.vec
v.vec = v.vec-step.size * (v.gradient / n.observations)
v.vec
library(NeuralNetwork1)
NNetIterations(X.mat,y.vec,3L,0.5,3L,c(TRUE,TRUE,TRUE,FALSE))
dim(pred.mat)
pred.mat
v.vec
library(NeuralNetwork1)
pred.mat=(NNetIterations(X.mat,y.vec,3L,0.5,3L,c(TRUE,TRUE,TRUE,FALSE)))
pred.mat
NNetIterations(X.mat,y.vec,3L,0.5,3L,c(TRUE,TRUE,TRUE,FALSE))
for(iteration in max.iterations){
for (index in dim(X.scaled.train)[1]){
v.vec = as.vector(v.vec)
Xi.train.vec=X.scaled.train[index,]
Xi.train.a=Xi.train.vec%*%W.mat
Xi.train.z=sigmoid(Xi.train.a)
Xi.train.b=Xi.train.z%*%v.vec
if (is.binary)
yi.hat = sigmoid(Xi.train.b) else
yi.hat=Xi.train.b
v.gradient.i=0.5*(yi.hat-y.train[index])%*%Xi.train.z
W.gradient.i=0.5*t(Xi.train.a%*%diag(sigmoid_return(v.vec)))%*%(yi.hat-y.train[index])%*%X.scaled.train[index,]
v.gradient = v.gradient + v.gradient.i
W.gradient = w.gradient + t(w.gradient.i)
}
v.vec = v.vec-step.size * (v.gradient / n.observations)
W.mat = W.mat - step.size * (W.gradient / n.observations)
pred.vec=sigmoid(X.scaled.mat%*%W.mat)%*%as.vector(v.vec)
if(is.binary)
pred.vec = sigmoid(pred.vec)
pred.mat[,iteration]= pred.vec
}
index
iteration
pred.vec
pred.mat
for (index in dim(X.scaled.train)[1]){
v.vec = as.vector(v.vec)
Xi.train.vec=X.scaled.train[index,]
Xi.train.a=Xi.train.vec%*%W.mat
Xi.train.z=sigmoid(Xi.train.a)
Xi.train.b=Xi.train.z%*%v.vec
if (is.binary)
yi.hat = sigmoid(Xi.train.b) else
yi.hat=Xi.train.b
v.gradient.i=0.5*(yi.hat-y.train[index])%*%Xi.train.z
W.gradient.i=0.5*t(Xi.train.a%*%diag(sigmoid_return(v.vec)))%*%(yi.hat-y.train[index])%*%X.scaled.train[index,]
v.gradient = v.gradient + v.gradient.i
W.gradient = w.gradient + t(w.gradient.i)
}
W.gradient
v.vec = v.vec-step.size * (v.gradient / n.observations)
W.mat = W.mat - step.size * (W.gradient / n.observations)
pred.vec=sigmoid(X.scaled.mat%*%W.mat)%*%as.vector(v.vec)
pred.vec
if(is.binary)
pred.vec = sigmoid(pred.vec)
pred.mat[,iteration]= pred.vec
pred.mat[,1]= pred.vec
pred.mat
pred.mat[,2]=pred.vec
pred.mat
pred.mat = matrix(0,n.observations, max.iterations)
W.mat
for(iteration in max.iterations){
# for (index in dim(X.scaled.train)[1]){
#   v.vec = as.vector(v.vec)
#   Xi.train.vec=X.scaled.train[index,]
#   Xi.train.a=Xi.train.vec%*%W.mat
#   Xi.train.z=sigmoid(Xi.train.a)
#   Xi.train.b=Xi.train.z%*%v.vec
#  if (is.binary)
#    yi.hat = sigmoid(Xi.train.b) else
#   yi.hat=Xi.train.b
#   v.gradient.i=0.5*(yi.hat-y.train[index])%*%Xi.train.z
#   W.gradient.i=0.5*t(Xi.train.a%*%diag(sigmoid_return(v.vec)))%*%(yi.hat-y.train[index])%*%X.scaled.train[index,]
#   v.gradient = v.gradient + v.gradient.i
#   W.gradient = w.gradient + t(w.gradient.i)
# }
v.vec = v.vec-step.size * (v.gradient / n.observations)
W.mat = W.mat - step.size * (W.gradient / n.observations)
pred.vec=sigmoid(X.scaled.mat%*%W.mat)%*%as.vector(v.vec)
if(is.binary)
pred.vec = sigmoid(pred.vec)
pred.mat[,iteration]= pred.vec
}
pred.mat
for(i in max.iterations){
# for (index in dim(X.scaled.train)[1]){
#   v.vec = as.vector(v.vec)
#   Xi.train.vec=X.scaled.train[index,]
#   Xi.train.a=Xi.train.vec%*%W.mat
#   Xi.train.z=sigmoid(Xi.train.a)
#   Xi.train.b=Xi.train.z%*%v.vec
#  if (is.binary)
#    yi.hat = sigmoid(Xi.train.b) else
#   yi.hat=Xi.train.b
#   v.gradient.i=0.5*(yi.hat-y.train[index])%*%Xi.train.z
#   W.gradient.i=0.5*t(Xi.train.a%*%diag(sigmoid_return(v.vec)))%*%(yi.hat-y.train[index])%*%X.scaled.train[index,]
#   v.gradient = v.gradient + v.gradient.i
#   W.gradient = w.gradient + t(w.gradient.i)
# }
v.vec = v.vec-step.size * (v.gradient / n.observations)
W.mat = W.mat - step.size * (W.gradient / n.observations)
pred.vec=sigmoid(X.scaled.mat%*%W.mat)%*%as.vector(v.vec)
if(is.binary)
pred.vec = sigmoid(pred.vec)
pred.mat[,iteration]= pred.vec
}
pred.mat
for(i in 3){
v.vec = v.vec-step.size * (v.gradient / n.observations)
W.mat = W.mat - step.size * (W.gradient / n.observations)
pred.vec=sigmoid(X.scaled.mat%*%W.mat)%*%as.vector(v.vec)
if(is.binary)
pred.vec = sigmoid(pred.vec)
pred.mat[,iteration]= pred.vec
}
pre.mat
pred.mat
for(i in 3){
v.vec = v.vec-step.size * (v.gradient / n.observations)
W.mat = W.mat - step.size * (W.gradient / n.observations)
pred.vec=sigmoid(X.scaled.mat%*%W.mat)%*%as.vector(v.vec)
if(is.binary)
pred.vec = sigmoid(pred.vec)
pred.mat[,i]= pred.vec
}
pred.mat
for(i in 3){}
for(i in 3){a=a+1}
a
for(i in 3){a=a+1}
a
for(1 in 3){a=a+1}
for(i in 4){a=a+1}
a
library(NeuralNetwork1)
library(NeuralNetwork1)
NNetIterations(X.mat,y.vec,3L,0.5,3L,c(TRUE,TRUE,TRUE,FALSE))
library(NeuralNetwork1)
NNetIterations(X.mat,y.vec,3L,0.5,3L,c(TRUE,TRUE,TRUE,FALSE))
a=NNetIterations(X.mat,y.vec,3L,0.5,3L,c(TRUE,TRUE,TRUE,FALSE))
a
